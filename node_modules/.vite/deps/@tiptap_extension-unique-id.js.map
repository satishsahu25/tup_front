{
  "version": 3,
  "sources": ["../../@tiptap/extension-unique-id/src/unique-id.ts", "../../@tiptap/extension-unique-id/src/helpers/removeDuplicates.ts", "../../@tiptap/extension-unique-id/src/helpers/findDuplicates.ts", "../../@tiptap/extension-unique-id/src/generate-unique-ids.ts", "../../@tiptap/extension-unique-id/src/index.ts"],
  "sourcesContent": ["import { combineTransactionSteps, Extension, findChildren, findChildrenInRange, getChangedRanges } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Fragment, Slice } from '@tiptap/pm/model'\nimport type { Transaction } from '@tiptap/pm/state'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport { findDuplicates } from './helpers/findDuplicates.js'\n\nexport type UniqueIDGenerationContext = {\n  node: ProseMirrorNode\n  pos: number\n}\n\nexport interface UniqueIDOptions {\n  /**\n   * The name of the attribute to add the unique ID to.\n   * @default \"id\"\n   */\n  attributeName: string\n  /**\n   * The types of nodes to add unique IDs to.\n   * @default []\n   */\n  types: string[]\n  /**\n   * The function that generates the unique ID. By default, a UUID v4 is\n   * generated. However, you can provide your own function to generate the\n   * unique ID based on the node type and the position.\n   */\n  generateID: (ctx: UniqueIDGenerationContext) => any\n  /**\n   * Ignore some mutations, for example applied from other users through the collaboration plugin.\n   *\n   * @default null\n   */\n  filterTransaction: ((transaction: Transaction) => boolean) | null\n  /**\n   * Whether to update the document by adding unique IDs to the nodes. Set this\n   * property to `false` if the document is in `readonly` mode, is immutable, or\n   * you don't want it to be modified.\n   *\n   * @default true\n   */\n  updateDocument: boolean\n}\n\nexport const UniqueID = Extension.create<UniqueIDOptions>({\n  name: 'uniqueID',\n\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 10000,\n\n  addOptions() {\n    return {\n      attributeName: 'id',\n      types: [],\n      generateID: () => uuidv4(),\n      filterTransaction: null,\n      updateDocument: true,\n    }\n  },\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: element => element.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: attributes => {\n              if (!attributes[this.options.attributeName]) {\n                return {}\n              }\n\n              return {\n                [`data-${this.options.attributeName}`]: attributes[this.options.attributeName],\n              }\n            },\n          },\n        },\n      },\n    ]\n  },\n\n  // check initial content for missing ids\n  onCreate() {\n    if (!this.options.updateDocument) {\n      return\n    }\n\n    const collaboration = this.editor.extensionManager.extensions.find(ext => ext.name === 'collaboration')\n    const collaborationCaret = this.editor.extensionManager.extensions.find(ext => ext.name === 'collaborationCaret')\n\n    const collabExtensions = [collaboration, collaborationCaret].filter(Boolean)\n    const collab = collabExtensions.find(ext => ext?.options?.provider)\n    const provider = collab?.options?.provider\n\n    const createIds = () => {\n      const { view, state } = this.editor\n      const { tr, doc } = state\n      const { types, attributeName, generateID } = this.options\n      const nodesWithoutId = findChildren(doc, node => {\n        return types.includes(node.type.name) && node.attrs[attributeName] === null\n      })\n\n      nodesWithoutId.forEach(({ node, pos }) => {\n        tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          [attributeName]: generateID({ node, pos }),\n        })\n      })\n\n      tr.setMeta('addToHistory', false)\n\n      view.dispatch(tr)\n\n      if (provider) {\n        provider.off('synced', createIds)\n      }\n    }\n\n    /**\n     * We need to handle collaboration a bit different here\n     * because we can't automatically add IDs when the provider is not yet synced\n     * otherwise we end up with empty paragraphs\n     */\n    if (collab) {\n      if (!provider) {\n        return createIds()\n      }\n\n      provider.on('synced', createIds)\n    } else {\n      return createIds()\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.updateDocument) {\n      return []\n    }\n\n    let dragSourceElement: Element | null = null\n    let transformPasted = false\n\n    return [\n      new Plugin({\n        key: new PluginKey('uniqueID'),\n\n        appendTransaction: (transactions, oldState, newState) => {\n          const hasDocChanges =\n            transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n          const filterTransactions =\n            this.options.filterTransaction && transactions.some(tr => !this.options.filterTransaction?.(tr))\n\n          const isCollabTransaction = transactions.find(tr => tr.getMeta('y-sync$'))\n\n          if (isCollabTransaction) {\n            return\n          }\n\n          if (!hasDocChanges || filterTransactions) {\n            return\n          }\n\n          const { tr } = newState\n\n          const { types, attributeName, generateID } = this.options\n          const transform = combineTransactionSteps(oldState.doc, transactions as Transaction[])\n          const { mapping } = transform\n\n          // get changed ranges based on the old state\n          const changes = getChangedRanges(transform)\n\n          changes.forEach(({ newRange }) => {\n            const newNodes = findChildrenInRange(newState.doc, newRange, node => {\n              return types.includes(node.type.name)\n            })\n\n            const newIds = newNodes.map(({ node }) => node.attrs[attributeName]).filter(id => id !== null)\n\n            newNodes.forEach(({ node, pos }, i) => {\n              // instead of checking `node.attrs[attributeName]` directly\n              // we look at the current state of the node within `tr.doc`.\n              // this helps to prevent adding new ids to the same node\n              // if the node changed multiple times within one transaction\n              const id = tr.doc.nodeAt(pos)?.attrs[attributeName]\n\n              if (id === null) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID({ node, pos }),\n                })\n\n                return\n              }\n\n              const nextNode = newNodes[i + 1]\n\n              if (nextNode && node.content.size === 0) {\n                tr.setNodeMarkup(nextNode.pos, undefined, {\n                  ...nextNode.node.attrs,\n                  [attributeName]: id,\n                })\n                newIds[i + 1] = id\n\n                if (nextNode.node.attrs[attributeName]) {\n                  return\n                }\n\n                const generatedId = generateID({ node, pos })\n\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generatedId,\n                })\n                newIds[i] = generatedId\n\n                return tr\n              }\n\n              const duplicatedNewIds = findDuplicates(newIds)\n\n              // check if the node doesn’t exist in the old state\n              const { deleted } = mapping.invert().mapResult(pos)\n\n              const newNode = deleted && duplicatedNewIds.includes(id)\n\n              if (newNode) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID({ node, pos }),\n                })\n              }\n            })\n          })\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          // `tr.setNodeMarkup` resets the stored marks\n          // so we'll restore them if they exist\n          tr.setStoredMarks(newState.tr.storedMarks)\n\n          // Mark this transaction as coming from UniqueID\n          // to prevent infinite loops with other extensions (e.g., TrailingNode)\n          tr.setMeta('__uniqueIDTransaction', true)\n\n          return tr\n        },\n\n        // we register a global drag handler to track the current drag source element\n        view(view) {\n          const handleDragstart = (event: DragEvent) => {\n            dragSourceElement = view.dom.parentElement?.contains(event.target as Element)\n              ? view.dom.parentElement\n              : null\n          }\n\n          window.addEventListener('dragstart', handleDragstart)\n\n          return {\n            destroy() {\n              window.removeEventListener('dragstart', handleDragstart)\n            },\n          }\n        },\n\n        props: {\n          // `handleDOMEvents` is called before `transformPasted`\n          // so we can do some checks before\n          handleDOMEvents: {\n            // only create new ids for dropped content\n            // or dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (view, event) => {\n              if (\n                dragSourceElement !== view.dom.parentElement ||\n                event.dataTransfer?.effectAllowed === 'copyMove' ||\n                event.dataTransfer?.effectAllowed === 'copy'\n              ) {\n                dragSourceElement = null\n                transformPasted = true\n              }\n\n              return false\n            },\n            // always create new ids on pasted content\n            paste: () => {\n              transformPasted = true\n\n              return false\n            },\n          },\n\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: slice => {\n            if (!transformPasted) {\n              return slice\n            }\n\n            const { types, attributeName } = this.options\n            const removeId = (fragment: Fragment): Fragment => {\n              const list: ProseMirrorNode[] = []\n\n              fragment.forEach(node => {\n                // don’t touch text nodes\n                if (node.isText) {\n                  list.push(node)\n\n                  return\n                }\n\n                // check for any other child nodes\n                if (!types.includes(node.type.name)) {\n                  list.push(node.copy(removeId(node.content)))\n\n                  return\n                }\n\n                // remove id\n                const nodeWithoutId = node.type.create(\n                  {\n                    ...node.attrs,\n                    [attributeName]: null,\n                  },\n                  removeId(node.content),\n                  node.marks,\n                )\n\n                list.push(nodeWithoutId)\n              })\n\n              return Fragment.from(list)\n            }\n\n            // reset check\n            transformPasted = false\n\n            return new Slice(removeId(slice.content), slice.openStart, slice.openEnd)\n          },\n        },\n      }),\n    ]\n  },\n})\n", "/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : (seen[key] = true)\n  })\n}\n", "import { removeDuplicates } from './removeDuplicates.js'\n\n/**\n * Returns a list of duplicated items within an array.\n */\nexport function findDuplicates(items: any[]): any[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n  const duplicates = removeDuplicates(filtered)\n\n  return duplicates\n}\n", "import type { Extensions, JSONContent } from '@tiptap/core'\nimport { findChildren, getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport type { UniqueID } from './unique-id.js'\n\n/**\n * Creates a new document with unique IDs added to the nodes. Does the same\n * thing as the UniqueID extension, but without the need to create an `Editor`\n * instance. This lets you add unique IDs to the document in the server.\n *\n * When you call it, include the `UniqueID` extension in the `extensions` array.\n * The configuration from the `UniqueID` extension will be picked up\n * automatically, including its configuration options like `types` and\n * `attributeName`.\n *\n * @see `UniqueID` extension for more information.\n *\n * @throws {Error} If the `UniqueID` extension is not found in the extensions array.\n *\n * @example\n * const doc = {\n *   type: 'doc',\n *   content: [\n *     { type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }\n *   ]\n * }\n * const newDoc = addUniqueIds(doc, [StarterKit, UniqueID.configure({ types: ['paragraph', 'heading'] })])\n * console.log(newDoc)\n * // Result:\n * // {\n * //   type: 'doc',\n * //   content: [\n * //     { type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }], id: '123' }\n * //   ]\n * // }\n *\n * @param doc - A Tiptap JSON document to add unique IDs to.\n * @param extensions - The extensions to use. Must include the `UniqueID` extension.\n * @returns The updated Tiptap JSON document, with the unique IDs added to the nodes.\n */\nexport function generateUniqueIds(doc: JSONContent, extensions: Extensions): JSONContent {\n  // Find the UniqueID extension in the extensions array. If it's not found, throw an error.\n  const uniqueIDExtension = extensions.find(ext => ext.name === 'uniqueID') as typeof UniqueID | undefined\n  if (!uniqueIDExtension) {\n    throw new Error('UniqueID extension not found in the extensions array')\n  }\n  const { types, attributeName, generateID } = uniqueIDExtension.options\n\n  // Convert the JSON content to a ProseMirror node\n  const schema = getSchema([...extensions.filter(ext => ext.name !== 'uniqueID'), uniqueIDExtension])\n  const contentNode = Node.fromJSON(schema, doc)\n\n  // Find nodes that don't have a unique ID\n  const nodesWithoutId = findChildren(contentNode, node => {\n    return !node.attrs[attributeName] && types.includes(node.type.name)\n  })\n\n  // Edit the document to add unique IDs to the nodes that don't have a unique ID\n  let tr = EditorState.create({\n    doc: contentNode,\n  }).tr\n  // eslint-disable-next-line no-restricted-syntax\n  for (const { node, pos } of nodesWithoutId) {\n    tr = tr.setNodeAttribute(pos, attributeName, generateID({ node, pos }))\n  }\n\n  // Return the updated document\n  return tr.doc.toJSON()\n}\n", "import { UniqueID } from './unique-id.js'\n\nexport * from './generate-unique-ids.js'\nexport * from './unique-id.js'\n\nexport default UniqueID\n"],
  "mappings": "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",
  "names": ["_a", "tr", "findChildren"]
}
