{
  "version": 3,
  "sources": ["../../@tiptap/extension-bubble-menu/src/bubble-menu.ts", "../../@tiptap/extension-bubble-menu/src/bubble-menu-plugin.ts", "../../@tiptap/extension-bubble-menu/src/index.ts", "../../@tiptap/react/src/menus/BubbleMenu.tsx", "../../@tiptap/react/src/menus/FloatingMenu.tsx", "../../@tiptap/extension-floating-menu/src/floating-menu.ts", "../../@tiptap/extension-floating-menu/src/floating-menu-plugin.ts", "../../@tiptap/extension-floating-menu/src/index.ts"],
  "sourcesContent": ["import { Extension } from '@tiptap/core'\n\nimport type { BubbleMenuPluginProps } from './bubble-menu-plugin.js'\nimport { BubbleMenuPlugin } from './bubble-menu-plugin.js'\n\nexport type BubbleMenuOptions = Omit<BubbleMenuPluginProps, 'editor' | 'element'> & {\n  /**\n   * The DOM element that contains your menu.\n   * @type {HTMLElement}\n   * @default null\n   */\n  element: HTMLElement | null\n}\n\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */\nexport const BubbleMenu = Extension.create<BubbleMenuOptions>({\n  name: 'bubbleMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      pluginKey: 'bubbleMenu',\n      updateDelay: undefined,\n      appendTo: undefined,\n      shouldShow: null,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return []\n    }\n\n    return [\n      BubbleMenuPlugin({\n        pluginKey: this.options.pluginKey,\n        editor: this.editor,\n        element: this.options.element,\n        updateDelay: this.options.updateDelay,\n        options: this.options.options,\n        appendTo: this.options.appendTo,\n        getReferencedVirtualElement: this.options.getReferencedVirtualElement,\n        shouldShow: this.options.shouldShow,\n      }),\n    ]\n  },\n})\n", "import {\n  type Middleware,\n  type VirtualElement,\n  arrow,\n  autoPlacement,\n  computePosition,\n  flip,\n  hide,\n  inline,\n  offset,\n  shift,\n  size,\n} from '@floating-ui/dom'\nimport type { Editor } from '@tiptap/core'\nimport { isTextSelection, posToDOMRect } from '@tiptap/core'\nimport type { EditorState, PluginView, Transaction } from '@tiptap/pm/state'\nimport { NodeSelection, Plugin, PluginKey } from '@tiptap/pm/state'\nimport { CellSelection } from '@tiptap/pm/tables'\nimport type { EditorView } from '@tiptap/pm/view'\n\nfunction combineDOMRects(rect1: DOMRect, rect2: DOMRect): DOMRect {\n  const top = Math.min(rect1.top, rect2.top)\n  const bottom = Math.max(rect1.bottom, rect2.bottom)\n  const left = Math.min(rect1.left, rect2.left)\n  const right = Math.max(rect1.right, rect2.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  return new DOMRect(x, y, width, height)\n}\n\nexport interface BubbleMenuPluginProps {\n  /**\n   * The plugin key.\n   * @type {PluginKey | string}\n   * @default 'bubbleMenu'\n   */\n  pluginKey: PluginKey | string\n\n  /**\n   * The editor instance.\n   */\n  editor: Editor\n\n  /**\n   * The DOM element that contains your menu.\n   * @type {HTMLElement}\n   * @default null\n   */\n  element: HTMLElement\n\n  /**\n   * The delay in milliseconds before the menu should be updated.\n   * This can be useful to prevent performance issues.\n   * @type {number}\n   * @default 250\n   */\n  updateDelay?: number\n\n  /**\n   * The delay in milliseconds before the menu position should be updated on window resize.\n   * This can be useful to prevent performance issues.\n   * @type {number}\n   * @default 60\n   */\n  resizeDelay?: number\n\n  /**\n   * A function that determines whether the menu should be shown or not.\n   * If this function returns `false`, the menu will be hidden, otherwise it will be shown.\n   */\n  shouldShow?:\n    | ((props: {\n        editor: Editor\n        element: HTMLElement\n        view: EditorView\n        state: EditorState\n        oldState?: EditorState\n        from: number\n        to: number\n      }) => boolean)\n    | null\n\n  /**\n   * The DOM element to append your menu to. Default is the editor's parent element.\n   *\n   * Sometimes the menu needs to be appended to a different DOM context due to accessibility, clipping, or z-index issues.\n   *\n   * @type {HTMLElement}\n   * @default null\n   */\n  appendTo?: HTMLElement | (() => HTMLElement)\n\n  /**\n   * A function that returns the virtual element for the menu.\n   * This is useful when the menu needs to be positioned relative to a specific DOM element.\n   * @type {() => VirtualElement | null}\n   * @default Position based on the selection.\n   */\n  getReferencedVirtualElement?: () => VirtualElement | null\n\n  /**\n   * The options for the bubble menu. Those are passed to Floating UI and include options for the placement, offset, flip, shift, arrow, size, autoPlacement,\n   * hide, and inline middlewares.\n   * @default {}\n   * @see https://floating-ui.com/docs/computePosition#options\n   */\n  options?: {\n    strategy?: 'absolute' | 'fixed'\n    placement?:\n      | 'top'\n      | 'right'\n      | 'bottom'\n      | 'left'\n      | 'top-start'\n      | 'top-end'\n      | 'right-start'\n      | 'right-end'\n      | 'bottom-start'\n      | 'bottom-end'\n      | 'left-start'\n      | 'left-end'\n    offset?: Parameters<typeof offset>[0] | boolean\n    flip?: Parameters<typeof flip>[0] | boolean\n    shift?: Parameters<typeof shift>[0] | boolean\n    arrow?: Parameters<typeof arrow>[0] | false\n    size?: Parameters<typeof size>[0] | boolean\n    autoPlacement?: Parameters<typeof autoPlacement>[0] | boolean\n    hide?: Parameters<typeof hide>[0] | boolean\n    inline?: Parameters<typeof inline>[0] | boolean\n\n    onShow?: () => void\n    onHide?: () => void\n    onUpdate?: () => void\n    onDestroy?: () => void\n\n    /**\n     * The scrollable element that should be listened to when updating the position of the bubble menu.\n     * If not provided, the window will be used.\n     * @type {HTMLElement | Window}\n     */\n    scrollTarget?: HTMLElement | Window\n  }\n}\n\nexport type BubbleMenuViewProps = BubbleMenuPluginProps & {\n  view: EditorView\n}\n\nexport class BubbleMenuView implements PluginView {\n  public editor: Editor\n\n  public element: HTMLElement\n\n  public view: EditorView\n\n  public preventHide = false\n\n  public updateDelay: number\n\n  public resizeDelay: number\n\n  public appendTo: HTMLElement | (() => HTMLElement) | undefined\n\n  public getReferencedVirtualElement: (() => VirtualElement | null) | undefined\n\n  private updateDebounceTimer: number | undefined\n\n  private resizeDebounceTimer: number | undefined\n\n  private isVisible = false\n\n  private scrollTarget: HTMLElement | Window = window\n\n  private floatingUIOptions: NonNullable<BubbleMenuPluginProps['options']> = {\n    strategy: 'absolute',\n    placement: 'top',\n    offset: 8,\n    flip: {},\n    shift: {},\n    arrow: false,\n    size: false,\n    autoPlacement: false,\n    hide: false,\n    inline: false,\n    onShow: undefined,\n    onHide: undefined,\n    onUpdate: undefined,\n    onDestroy: undefined,\n  }\n\n  public shouldShow: Exclude<BubbleMenuPluginProps['shouldShow'], null> = ({ view, state, from, to }) => {\n    const { doc, selection } = state\n    const { empty } = selection\n\n    // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n    const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection)\n\n    // When clicking on a element inside the bubble menu the editor \"blur\" event\n    // is called and the bubble menu item is focussed. In this case we should\n    // consider the menu as part of the editor and keep showing the menu\n    const isChildOfMenu = this.element.contains(document.activeElement)\n\n    const hasEditorFocus = view.hasFocus() || isChildOfMenu\n\n    if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n      return false\n    }\n\n    return true\n  }\n\n  get middlewares() {\n    const middlewares: Middleware[] = []\n\n    if (this.floatingUIOptions.flip) {\n      middlewares.push(flip(typeof this.floatingUIOptions.flip !== 'boolean' ? this.floatingUIOptions.flip : undefined))\n    }\n\n    if (this.floatingUIOptions.shift) {\n      middlewares.push(\n        shift(typeof this.floatingUIOptions.shift !== 'boolean' ? this.floatingUIOptions.shift : undefined),\n      )\n    }\n\n    if (this.floatingUIOptions.offset) {\n      middlewares.push(\n        offset(typeof this.floatingUIOptions.offset !== 'boolean' ? this.floatingUIOptions.offset : undefined),\n      )\n    }\n\n    if (this.floatingUIOptions.arrow) {\n      middlewares.push(arrow(this.floatingUIOptions.arrow))\n    }\n\n    if (this.floatingUIOptions.size) {\n      middlewares.push(size(typeof this.floatingUIOptions.size !== 'boolean' ? this.floatingUIOptions.size : undefined))\n    }\n\n    if (this.floatingUIOptions.autoPlacement) {\n      middlewares.push(\n        autoPlacement(\n          typeof this.floatingUIOptions.autoPlacement !== 'boolean' ? this.floatingUIOptions.autoPlacement : undefined,\n        ),\n      )\n    }\n\n    if (this.floatingUIOptions.hide) {\n      middlewares.push(hide(typeof this.floatingUIOptions.hide !== 'boolean' ? this.floatingUIOptions.hide : undefined))\n    }\n\n    if (this.floatingUIOptions.inline) {\n      middlewares.push(\n        inline(typeof this.floatingUIOptions.inline !== 'boolean' ? this.floatingUIOptions.inline : undefined),\n      )\n    }\n\n    return middlewares\n  }\n\n  private get virtualElement(): VirtualElement | undefined {\n    const { selection } = this.editor.state\n\n    const referencedVirtualElement = this.getReferencedVirtualElement?.()\n    if (referencedVirtualElement) {\n      return referencedVirtualElement\n    }\n\n    const domRect = posToDOMRect(this.view, selection.from, selection.to)\n    let virtualElement = {\n      getBoundingClientRect: () => domRect,\n      getClientRects: () => [domRect],\n    }\n\n    if (selection instanceof NodeSelection) {\n      let node = this.view.nodeDOM(selection.from) as HTMLElement\n\n      const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]')\n\n      if (nodeViewWrapper) {\n        node = nodeViewWrapper as HTMLElement\n      }\n\n      if (node) {\n        virtualElement = {\n          getBoundingClientRect: () => node.getBoundingClientRect(),\n          getClientRects: () => [node.getBoundingClientRect()],\n        }\n      }\n    }\n\n    // this is a special case for cell selections\n    if (selection instanceof CellSelection) {\n      const { $anchorCell, $headCell } = selection\n\n      const from = $anchorCell ? $anchorCell.pos : $headCell!.pos\n      const to = $headCell ? $headCell.pos : $anchorCell!.pos\n\n      const fromDOM = this.view.nodeDOM(from)\n      const toDOM = this.view.nodeDOM(to)\n\n      if (!fromDOM || !toDOM) {\n        return\n      }\n\n      const clientRect =\n        fromDOM === toDOM\n          ? (fromDOM as HTMLElement).getBoundingClientRect()\n          : combineDOMRects(\n              (fromDOM as HTMLElement).getBoundingClientRect(),\n              (toDOM as HTMLElement).getBoundingClientRect(),\n            )\n\n      virtualElement = {\n        getBoundingClientRect: () => clientRect,\n        getClientRects: () => [clientRect],\n      }\n    }\n\n    return virtualElement\n  }\n\n  constructor({\n    editor,\n    element,\n    view,\n    updateDelay = 250,\n    resizeDelay = 60,\n    shouldShow,\n    appendTo,\n    getReferencedVirtualElement,\n    options,\n  }: BubbleMenuViewProps) {\n    this.editor = editor\n    this.element = element\n    this.view = view\n    this.updateDelay = updateDelay\n    this.resizeDelay = resizeDelay\n    this.appendTo = appendTo\n    this.scrollTarget = options?.scrollTarget ?? window\n    this.getReferencedVirtualElement = getReferencedVirtualElement\n\n    this.floatingUIOptions = {\n      ...this.floatingUIOptions,\n      ...options,\n    }\n\n    this.element.tabIndex = 0\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler)\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n    this.editor.on('transaction', this.transactionHandler)\n    window.addEventListener('resize', this.resizeHandler)\n    this.scrollTarget.addEventListener('scroll', this.resizeHandler)\n\n    this.update(view, view.state)\n\n    if (this.getShouldShow()) {\n      this.show()\n      this.updatePosition()\n    }\n  }\n\n  mousedownHandler = () => {\n    this.preventHide = true\n  }\n\n  dragstartHandler = () => {\n    this.hide()\n  }\n\n  /**\n   * Handles the window resize event to update the position of the bubble menu.\n   * It uses a debounce mechanism to prevent excessive updates.\n   * The delay is defined by the `resizeDelay` property.\n   */\n  resizeHandler = () => {\n    if (this.resizeDebounceTimer) {\n      clearTimeout(this.resizeDebounceTimer)\n    }\n\n    this.resizeDebounceTimer = window.setTimeout(() => {\n      this.updatePosition()\n    }, this.resizeDelay)\n  }\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.editor.view))\n  }\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.editor.isDestroyed) {\n      this.destroy()\n      return\n    }\n\n    if (this.preventHide) {\n      this.preventHide = false\n\n      return\n    }\n\n    if (event?.relatedTarget && this.element.parentNode?.contains(event.relatedTarget as Node)) {\n      return\n    }\n\n    if (event?.relatedTarget === this.editor.view.dom) {\n      return\n    }\n\n    this.hide()\n  }\n\n  updatePosition() {\n    const virtualElement = this.virtualElement\n\n    if (!virtualElement) {\n      return\n    }\n\n    computePosition(virtualElement, this.element, {\n      placement: this.floatingUIOptions.placement,\n      strategy: this.floatingUIOptions.strategy,\n      middleware: this.middlewares,\n    }).then(({ x, y, strategy }) => {\n      this.element.style.width = 'max-content'\n      this.element.style.position = strategy\n      this.element.style.left = `${x}px`\n      this.element.style.top = `${y}px`\n\n      if (this.isVisible && this.floatingUIOptions.onUpdate) {\n        this.floatingUIOptions.onUpdate()\n      }\n    })\n  }\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state } = view\n    const hasValidSelection = state.selection.from !== state.selection.to\n\n    if (this.updateDelay > 0 && hasValidSelection) {\n      this.handleDebouncedUpdate(view, oldState)\n      return\n    }\n\n    const selectionChanged = !oldState?.selection.eq(view.state.selection)\n    const docChanged = !oldState?.doc.eq(view.state.doc)\n\n    this.updateHandler(view, selectionChanged, docChanged, oldState)\n  }\n\n  handleDebouncedUpdate = (view: EditorView, oldState?: EditorState) => {\n    const selectionChanged = !oldState?.selection.eq(view.state.selection)\n    const docChanged = !oldState?.doc.eq(view.state.doc)\n\n    if (!selectionChanged && !docChanged) {\n      return\n    }\n\n    if (this.updateDebounceTimer) {\n      clearTimeout(this.updateDebounceTimer)\n    }\n\n    this.updateDebounceTimer = window.setTimeout(() => {\n      this.updateHandler(view, selectionChanged, docChanged, oldState)\n    }, this.updateDelay)\n  }\n\n  getShouldShow(oldState?: EditorState) {\n    const { state } = this.view\n    const { selection } = state\n\n    // support for CellSelections\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      element: this.element,\n      view: this.view,\n      state,\n      oldState,\n      from,\n      to,\n    })\n\n    return shouldShow || false\n  }\n\n  updateHandler = (view: EditorView, selectionChanged: boolean, docChanged: boolean, oldState?: EditorState) => {\n    const { composing } = view\n\n    const isSame = !selectionChanged && !docChanged\n\n    if (composing || isSame) {\n      return\n    }\n\n    const shouldShow = this.getShouldShow(oldState)\n\n    if (!shouldShow) {\n      this.hide()\n\n      return\n    }\n\n    this.updatePosition()\n    this.show()\n  }\n\n  show() {\n    if (this.isVisible) {\n      return\n    }\n\n    this.element.style.visibility = 'visible'\n    this.element.style.opacity = '1'\n\n    // attach to appendTo or editor's parent element\n    const appendToElement = typeof this.appendTo === 'function' ? this.appendTo() : this.appendTo\n    ;(appendToElement ?? this.view.dom.parentElement)?.appendChild(this.element)\n\n    if (this.floatingUIOptions.onShow) {\n      this.floatingUIOptions.onShow()\n    }\n\n    this.isVisible = true\n  }\n\n  hide() {\n    if (!this.isVisible) {\n      return\n    }\n\n    this.element.style.visibility = 'hidden'\n    this.element.style.opacity = '0'\n    // remove from the parent element\n    this.element.remove()\n\n    if (this.floatingUIOptions.onHide) {\n      this.floatingUIOptions.onHide()\n    }\n\n    this.isVisible = false\n  }\n\n  transactionHandler = ({ transaction: tr }: { transaction: Transaction }) => {\n    const meta = tr.getMeta('bubbleMenu')\n    if (meta === 'updatePosition') {\n      this.updatePosition()\n    }\n  }\n\n  destroy() {\n    this.hide()\n    this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler)\n    window.removeEventListener('resize', this.resizeHandler)\n    this.scrollTarget.removeEventListener('scroll', this.resizeHandler)\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n    this.editor.off('transaction', this.transactionHandler)\n\n    if (this.floatingUIOptions.onDestroy) {\n      this.floatingUIOptions.onDestroy()\n    }\n  }\n}\n\nexport const BubbleMenuPlugin = (options: BubbleMenuPluginProps) => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new BubbleMenuView({ view, ...options }),\n  })\n}\n", "import { BubbleMenu } from './bubble-menu.js'\n\nexport * from './bubble-menu.js'\nexport * from './bubble-menu-plugin.js'\n\nexport default BubbleMenu\n", "import { type BubbleMenuPluginProps, BubbleMenuPlugin } from '@tiptap/extension-bubble-menu'\nimport { useCurrentEditor } from '@tiptap/react'\nimport React, { useEffect, useRef } from 'react'\nimport { createPortal } from 'react-dom'\n\ntype Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type BubbleMenuProps = Optional<Omit<Optional<BubbleMenuPluginProps, 'pluginKey'>, 'element'>, 'editor'> &\n  React.HTMLAttributes<HTMLDivElement>\n\nexport const BubbleMenu = React.forwardRef<HTMLDivElement, BubbleMenuProps>(\n  (\n    {\n      pluginKey = 'bubbleMenu',\n      editor,\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      shouldShow = null,\n      getReferencedVirtualElement,\n      options,\n      children,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const menuEl = useRef(document.createElement('div'))\n\n    if (typeof ref === 'function') {\n      ref(menuEl.current)\n    } else if (ref) {\n      ref.current = menuEl.current\n    }\n\n    const { editor: currentEditor } = useCurrentEditor()\n\n    /**\n     * The editor instance where the bubble menu plugin will be registered.\n     */\n    const pluginEditor = editor || currentEditor\n\n    // Creating a useMemo would be more computationally expensive than just\n    // re-creating this object on every render.\n    const bubbleMenuPluginProps: Omit<BubbleMenuPluginProps, 'editor' | 'element'> = {\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      pluginKey,\n      shouldShow,\n      getReferencedVirtualElement,\n      options,\n    }\n    /**\n     * The props for the bubble menu plugin. They are accessed inside a ref to\n     * avoid running the useEffect hook and re-registering the plugin when the\n     * props change.\n     */\n    const bubbleMenuPluginPropsRef = useRef(bubbleMenuPluginProps)\n    bubbleMenuPluginPropsRef.current = bubbleMenuPluginProps\n\n    useEffect(() => {\n      if (pluginEditor?.isDestroyed) {\n        return\n      }\n\n      if (!pluginEditor) {\n        console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.')\n        return\n      }\n\n      const bubbleMenuElement = menuEl.current\n      bubbleMenuElement.style.visibility = 'hidden'\n      bubbleMenuElement.style.position = 'absolute'\n\n      const plugin = BubbleMenuPlugin({\n        ...bubbleMenuPluginPropsRef.current,\n        editor: pluginEditor,\n        element: bubbleMenuElement,\n      })\n\n      pluginEditor.registerPlugin(plugin)\n\n      const createdPluginKey = bubbleMenuPluginPropsRef.current.pluginKey\n\n      return () => {\n        pluginEditor.unregisterPlugin(createdPluginKey)\n        window.requestAnimationFrame(() => {\n          if (bubbleMenuElement.parentNode) {\n            bubbleMenuElement.parentNode.removeChild(bubbleMenuElement)\n          }\n        })\n      }\n    }, [pluginEditor])\n\n    return createPortal(<div {...restProps}>{children}</div>, menuEl.current)\n  },\n)\n", "import type { FloatingMenuPluginProps } from '@tiptap/extension-floating-menu'\nimport { FloatingMenuPlugin } from '@tiptap/extension-floating-menu'\nimport { useCurrentEditor } from '@tiptap/react'\nimport React, { useEffect, useRef } from 'react'\nimport { createPortal } from 'react-dom'\n\ntype Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type FloatingMenuProps = Omit<Optional<FloatingMenuPluginProps, 'pluginKey'>, 'element' | 'editor'> & {\n  editor: FloatingMenuPluginProps['editor'] | null\n  options?: FloatingMenuPluginProps['options']\n} & React.HTMLAttributes<HTMLDivElement>\n\nexport const FloatingMenu = React.forwardRef<HTMLDivElement, FloatingMenuProps>(\n  ({ pluginKey = 'floatingMenu', editor, appendTo, shouldShow = null, options, children, ...restProps }, ref) => {\n    const menuEl = useRef(document.createElement('div'))\n\n    if (typeof ref === 'function') {\n      ref(menuEl.current)\n    } else if (ref) {\n      ref.current = menuEl.current\n    }\n\n    const { editor: currentEditor } = useCurrentEditor()\n\n    useEffect(() => {\n      const floatingMenuElement = menuEl.current\n\n      floatingMenuElement.style.visibility = 'hidden'\n      floatingMenuElement.style.position = 'absolute'\n\n      if (editor?.isDestroyed || (currentEditor as any)?.isDestroyed) {\n        return\n      }\n\n      const attachToEditor = editor || currentEditor\n\n      if (!attachToEditor) {\n        console.warn(\n          'FloatingMenu component is not rendered inside of an editor component or does not have editor prop.',\n        )\n        return\n      }\n\n      const plugin = FloatingMenuPlugin({\n        editor: attachToEditor,\n        element: floatingMenuElement,\n        pluginKey,\n        appendTo,\n        shouldShow,\n        options,\n      })\n\n      attachToEditor.registerPlugin(plugin)\n\n      return () => {\n        attachToEditor.unregisterPlugin(pluginKey)\n        window.requestAnimationFrame(() => {\n          if (floatingMenuElement.parentNode) {\n            floatingMenuElement.parentNode.removeChild(floatingMenuElement)\n          }\n        })\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [editor, currentEditor, appendTo, pluginKey, shouldShow, options])\n\n    return createPortal(<div {...restProps}>{children}</div>, menuEl.current)\n  },\n)\n", "import { Extension } from '@tiptap/core'\n\nimport type { FloatingMenuPluginProps } from './floating-menu-plugin.js'\nimport { FloatingMenuPlugin } from './floating-menu-plugin.js'\n\nexport type FloatingMenuOptions = Omit<FloatingMenuPluginProps, 'editor' | 'element'> & {\n  /**\n   * The DOM element that contains your menu.\n   * @type {HTMLElement}\n   * @default null\n   */\n  element: HTMLElement | null\n}\n\n/**\n * This extension allows you to create a floating menu.\n * @see https://tiptap.dev/api/extensions/floating-menu\n */\nexport const FloatingMenu = Extension.create<FloatingMenuOptions>({\n  name: 'floatingMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      options: {},\n      pluginKey: 'floatingMenu',\n      appendTo: undefined,\n      shouldShow: null,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return []\n    }\n\n    return [\n      FloatingMenuPlugin({\n        pluginKey: this.options.pluginKey,\n        editor: this.editor,\n        element: this.options.element,\n        options: this.options.options,\n        appendTo: this.options.appendTo,\n        shouldShow: this.options.shouldShow,\n      }),\n    ]\n  },\n})\n", "import {\n  type Middleware,\n  arrow,\n  autoPlacement,\n  computePosition,\n  flip,\n  hide,\n  inline,\n  offset,\n  shift,\n  size,\n} from '@floating-ui/dom'\nimport type { Editor } from '@tiptap/core'\nimport { getText, getTextSerializersFromSchema, posToDOMRect } from '@tiptap/core'\nimport type { Node as ProsemirrorNode } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport type { EditorView } from '@tiptap/pm/view'\n\nexport interface FloatingMenuPluginProps {\n  /**\n   * The plugin key for the floating menu.\n   * @default 'floatingMenu'\n   */\n  pluginKey: PluginKey | string\n\n  /**\n   * The editor instance.\n   * @default null\n   */\n  editor: Editor\n\n  /**\n   * The DOM element that contains your menu.\n   * @default null\n   */\n  element: HTMLElement\n\n  /**\n   * The DOM element to append your menu to. Default is the editor's parent element.\n   *\n   * Sometimes the menu needs to be appended to a different DOM context due to accessibility, clipping, or z-index issues.\n   *\n   * @type {HTMLElement}\n   * @default null\n   */\n  appendTo?: HTMLElement | (() => HTMLElement)\n\n  /**\n   * A function that determines whether the menu should be shown or not.\n   * If this function returns `false`, the menu will be hidden, otherwise it will be shown.\n   */\n  shouldShow?:\n    | ((props: {\n        editor: Editor\n        view: EditorView\n        state: EditorState\n        oldState?: EditorState\n        from: number\n        to: number\n      }) => boolean)\n    | null\n\n  /**\n   * The options for the floating menu. Those are passed to Floating UI and include options for the placement, offset, flip, shift, arrow, size, autoPlacement,\n   * hide, and inline middlewares.\n   * @default {}\n   * @see https://floating-ui.com/docs/computePosition#options\n   */\n  options?: {\n    strategy?: 'absolute' | 'fixed'\n    placement?:\n      | 'top'\n      | 'right'\n      | 'bottom'\n      | 'left'\n      | 'top-start'\n      | 'top-end'\n      | 'right-start'\n      | 'right-end'\n      | 'bottom-start'\n      | 'bottom-end'\n      | 'left-start'\n      | 'left-end'\n    offset?: Parameters<typeof offset>[0] | boolean\n    flip?: Parameters<typeof flip>[0] | boolean\n    shift?: Parameters<typeof shift>[0] | boolean\n    arrow?: Parameters<typeof arrow>[0] | false\n    size?: Parameters<typeof size>[0] | boolean\n    autoPlacement?: Parameters<typeof autoPlacement>[0] | boolean\n    hide?: Parameters<typeof hide>[0] | boolean\n    inline?: Parameters<typeof inline>[0] | boolean\n\n    onShow?: () => void\n    onHide?: () => void\n    onUpdate?: () => void\n    onDestroy?: () => void\n  }\n}\n\nexport type FloatingMenuViewProps = FloatingMenuPluginProps & {\n  /**\n   * The editor view.\n   */\n  view: EditorView\n}\n\nexport class FloatingMenuView {\n  public editor: Editor\n\n  public element: HTMLElement\n\n  public view: EditorView\n\n  public appendTo: HTMLElement | (() => HTMLElement) | undefined\n\n  public preventHide = false\n\n  private isVisible = false\n\n  private getTextContent(node: ProsemirrorNode) {\n    return getText(node, { textSerializers: getTextSerializersFromSchema(this.editor.schema) })\n  }\n\n  public shouldShow: Exclude<FloatingMenuPluginProps['shouldShow'], null> = ({ view, state }) => {\n    const { selection } = state\n    const { $anchor, empty } = selection\n    const isRootDepth = $anchor.depth === 1\n\n    const isEmptyTextBlock =\n      $anchor.parent.isTextblock &&\n      !$anchor.parent.type.spec.code &&\n      !$anchor.parent.textContent &&\n      $anchor.parent.childCount === 0 &&\n      !this.getTextContent($anchor.parent)\n\n    if (!view.hasFocus() || !empty || !isRootDepth || !isEmptyTextBlock || !this.editor.isEditable) {\n      return false\n    }\n\n    return true\n  }\n\n  private floatingUIOptions: NonNullable<FloatingMenuPluginProps['options']> = {\n    strategy: 'absolute',\n    placement: 'right',\n    offset: 8,\n    flip: {},\n    shift: {},\n    arrow: false,\n    size: false,\n    autoPlacement: false,\n    hide: false,\n    inline: false,\n  }\n\n  get middlewares() {\n    const middlewares: Middleware[] = []\n\n    if (this.floatingUIOptions.flip) {\n      middlewares.push(flip(typeof this.floatingUIOptions.flip !== 'boolean' ? this.floatingUIOptions.flip : undefined))\n    }\n\n    if (this.floatingUIOptions.shift) {\n      middlewares.push(\n        shift(typeof this.floatingUIOptions.shift !== 'boolean' ? this.floatingUIOptions.shift : undefined),\n      )\n    }\n\n    if (this.floatingUIOptions.offset) {\n      middlewares.push(\n        offset(typeof this.floatingUIOptions.offset !== 'boolean' ? this.floatingUIOptions.offset : undefined),\n      )\n    }\n\n    if (this.floatingUIOptions.arrow) {\n      middlewares.push(arrow(this.floatingUIOptions.arrow))\n    }\n\n    if (this.floatingUIOptions.size) {\n      middlewares.push(size(typeof this.floatingUIOptions.size !== 'boolean' ? this.floatingUIOptions.size : undefined))\n    }\n\n    if (this.floatingUIOptions.autoPlacement) {\n      middlewares.push(\n        autoPlacement(\n          typeof this.floatingUIOptions.autoPlacement !== 'boolean' ? this.floatingUIOptions.autoPlacement : undefined,\n        ),\n      )\n    }\n\n    if (this.floatingUIOptions.hide) {\n      middlewares.push(hide(typeof this.floatingUIOptions.hide !== 'boolean' ? this.floatingUIOptions.hide : undefined))\n    }\n\n    if (this.floatingUIOptions.inline) {\n      middlewares.push(\n        inline(typeof this.floatingUIOptions.inline !== 'boolean' ? this.floatingUIOptions.inline : undefined),\n      )\n    }\n\n    return middlewares\n  }\n\n  constructor({ editor, element, view, options, appendTo, shouldShow }: FloatingMenuViewProps) {\n    this.editor = editor\n    this.element = element\n    this.view = view\n    this.appendTo = appendTo\n\n    this.floatingUIOptions = {\n      ...this.floatingUIOptions,\n      ...options,\n    }\n\n    this.element.tabIndex = 0\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n\n    this.update(view, view.state)\n\n    if (this.getShouldShow()) {\n      this.show()\n      this.updatePosition()\n    }\n  }\n\n  getShouldShow(oldState?: EditorState) {\n    const { state } = this.view\n    const { selection } = state\n\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      view: this.view,\n      state,\n      oldState,\n      from,\n      to,\n    })\n\n    return shouldShow\n  }\n\n  updateHandler = (view: EditorView, selectionChanged: boolean, docChanged: boolean, oldState?: EditorState) => {\n    const { composing } = view\n\n    const isSame = !selectionChanged && !docChanged\n\n    if (composing || isSame) {\n      return\n    }\n\n    const shouldShow = this.getShouldShow(oldState)\n\n    if (!shouldShow) {\n      this.hide()\n\n      return\n    }\n\n    this.updatePosition()\n    this.show()\n  }\n\n  mousedownHandler = () => {\n    this.preventHide = true\n  }\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.editor.view))\n  }\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.preventHide) {\n      this.preventHide = false\n\n      return\n    }\n\n    if (event?.relatedTarget && this.element.parentNode?.contains(event.relatedTarget as Node)) {\n      return\n    }\n\n    if (event?.relatedTarget === this.editor.view.dom) {\n      return\n    }\n\n    this.hide()\n  }\n\n  updatePosition() {\n    const { selection } = this.editor.state\n\n    const domRect = posToDOMRect(this.view, selection.from, selection.to)\n\n    const virtualElement = {\n      getBoundingClientRect: () => domRect,\n      getClientRects: () => [domRect],\n    }\n\n    computePosition(virtualElement, this.element, {\n      placement: this.floatingUIOptions.placement,\n      strategy: this.floatingUIOptions.strategy,\n      middleware: this.middlewares,\n    }).then(({ x, y, strategy }) => {\n      this.element.style.width = 'max-content'\n      this.element.style.position = strategy\n      this.element.style.left = `${x}px`\n      this.element.style.top = `${y}px`\n\n      if (this.isVisible && this.floatingUIOptions.onUpdate) {\n        this.floatingUIOptions.onUpdate()\n      }\n    })\n  }\n\n  update(view: EditorView, oldState?: EditorState) {\n    const selectionChanged = !oldState?.selection.eq(view.state.selection)\n    const docChanged = !oldState?.doc.eq(view.state.doc)\n\n    this.updateHandler(view, selectionChanged, docChanged, oldState)\n  }\n\n  show() {\n    if (this.isVisible) {\n      return\n    }\n\n    this.element.style.visibility = 'visible'\n    this.element.style.opacity = '1'\n\n    // attach to appendTo or editor's parent element\n    const appendToElement = typeof this.appendTo === 'function' ? this.appendTo() : this.appendTo\n    ;(appendToElement ?? this.view.dom.parentElement)?.appendChild(this.element)\n\n    if (this.floatingUIOptions.onShow) {\n      this.floatingUIOptions.onShow()\n    }\n\n    this.isVisible = true\n  }\n\n  hide() {\n    if (!this.isVisible) {\n      return\n    }\n\n    this.element.style.visibility = 'hidden'\n    this.element.style.opacity = '0'\n    // remove from the parent element\n    this.element.remove()\n\n    if (this.floatingUIOptions.onHide) {\n      this.floatingUIOptions.onHide()\n    }\n\n    this.isVisible = false\n  }\n\n  destroy() {\n    this.hide()\n    this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n\n    if (this.floatingUIOptions.onDestroy) {\n      this.floatingUIOptions.onDestroy()\n    }\n  }\n}\n\nexport const FloatingMenuPlugin = (options: FloatingMenuPluginProps) => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new FloatingMenuView({ view, ...options }),\n  })\n}\n", "import { FloatingMenu } from './floating-menu.js'\n\nexport * from './floating-menu.js'\nexport * from './floating-menu-plugin.js'\n\nexport default FloatingMenu\n"],
  "mappings": "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",
  "names": ["view", "_a", "shouldShow", "import_react", "view", "shouldShow", "import_react", "import_react_dom", "import_jsx_runtime", "BubbleMenu", "React", "FloatingMenu", "useRef", "useCurrentEditor", "useEffect", "createPortal", "jsx"]
}
