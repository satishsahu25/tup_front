"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  UniqueID: () => UniqueID,
  default: () => index_default,
  generateUniqueIds: () => generateUniqueIds
});
module.exports = __toCommonJS(index_exports);

// src/unique-id.ts
var import_core = require("@tiptap/core");
var import_model = require("@tiptap/pm/model");
var import_state = require("@tiptap/pm/state");
var import_uuid = require("uuid");

// src/helpers/removeDuplicates.ts
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}

// src/helpers/findDuplicates.ts
function findDuplicates(items) {
  const filtered = items.filter((el, index) => items.indexOf(el) !== index);
  const duplicates = removeDuplicates(filtered);
  return duplicates;
}

// src/unique-id.ts
var UniqueID = import_core.Extension.create({
  name: "uniqueID",
  // we’ll set a very high priority to make sure this runs first
  // and is compatible with `appendTransaction` hooks of other extensions
  priority: 1e4,
  addOptions() {
    return {
      attributeName: "id",
      types: [],
      generateID: () => (0, import_uuid.v4)(),
      filterTransaction: null,
      updateDocument: true
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          [this.options.attributeName]: {
            default: null,
            parseHTML: (element) => element.getAttribute(`data-${this.options.attributeName}`),
            renderHTML: (attributes) => {
              if (!attributes[this.options.attributeName]) {
                return {};
              }
              return {
                [`data-${this.options.attributeName}`]: attributes[this.options.attributeName]
              };
            }
          }
        }
      }
    ];
  },
  // check initial content for missing ids
  onCreate() {
    var _a;
    if (!this.options.updateDocument) {
      return;
    }
    const collaboration = this.editor.extensionManager.extensions.find((ext) => ext.name === "collaboration");
    const collaborationCaret = this.editor.extensionManager.extensions.find((ext) => ext.name === "collaborationCaret");
    const collabExtensions = [collaboration, collaborationCaret].filter(Boolean);
    const collab = collabExtensions.find((ext) => {
      var _a2;
      return (_a2 = ext == null ? void 0 : ext.options) == null ? void 0 : _a2.provider;
    });
    const provider = (_a = collab == null ? void 0 : collab.options) == null ? void 0 : _a.provider;
    const createIds = () => {
      const { view, state } = this.editor;
      const { tr, doc } = state;
      const { types, attributeName, generateID } = this.options;
      const nodesWithoutId = (0, import_core.findChildren)(doc, (node) => {
        return types.includes(node.type.name) && node.attrs[attributeName] === null;
      });
      nodesWithoutId.forEach(({ node, pos }) => {
        tr.setNodeMarkup(pos, void 0, {
          ...node.attrs,
          [attributeName]: generateID({ node, pos })
        });
      });
      tr.setMeta("addToHistory", false);
      view.dispatch(tr);
      if (provider) {
        provider.off("synced", createIds);
      }
    };
    if (collab) {
      if (!provider) {
        return createIds();
      }
      provider.on("synced", createIds);
    } else {
      return createIds();
    }
  },
  addProseMirrorPlugins() {
    if (!this.options.updateDocument) {
      return [];
    }
    let dragSourceElement = null;
    let transformPasted = false;
    return [
      new import_state.Plugin({
        key: new import_state.PluginKey("uniqueID"),
        appendTransaction: (transactions, oldState, newState) => {
          const hasDocChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const filterTransactions = this.options.filterTransaction && transactions.some((tr2) => {
            var _a, _b;
            return !((_b = (_a = this.options).filterTransaction) == null ? void 0 : _b.call(_a, tr2));
          });
          const isCollabTransaction = transactions.find((tr2) => tr2.getMeta("y-sync$"));
          if (isCollabTransaction) {
            return;
          }
          if (!hasDocChanges || filterTransactions) {
            return;
          }
          const { tr } = newState;
          const { types, attributeName, generateID } = this.options;
          const transform = (0, import_core.combineTransactionSteps)(oldState.doc, transactions);
          const { mapping } = transform;
          const changes = (0, import_core.getChangedRanges)(transform);
          changes.forEach(({ newRange }) => {
            const newNodes = (0, import_core.findChildrenInRange)(newState.doc, newRange, (node) => {
              return types.includes(node.type.name);
            });
            const newIds = newNodes.map(({ node }) => node.attrs[attributeName]).filter((id) => id !== null);
            newNodes.forEach(({ node, pos }, i) => {
              var _a;
              const id = (_a = tr.doc.nodeAt(pos)) == null ? void 0 : _a.attrs[attributeName];
              if (id === null) {
                tr.setNodeMarkup(pos, void 0, {
                  ...node.attrs,
                  [attributeName]: generateID({ node, pos })
                });
                return;
              }
              const nextNode = newNodes[i + 1];
              if (nextNode && node.content.size === 0) {
                tr.setNodeMarkup(nextNode.pos, void 0, {
                  ...nextNode.node.attrs,
                  [attributeName]: id
                });
                newIds[i + 1] = id;
                if (nextNode.node.attrs[attributeName]) {
                  return;
                }
                const generatedId = generateID({ node, pos });
                tr.setNodeMarkup(pos, void 0, {
                  ...node.attrs,
                  [attributeName]: generatedId
                });
                newIds[i] = generatedId;
                return tr;
              }
              const duplicatedNewIds = findDuplicates(newIds);
              const { deleted } = mapping.invert().mapResult(pos);
              const newNode = deleted && duplicatedNewIds.includes(id);
              if (newNode) {
                tr.setNodeMarkup(pos, void 0, {
                  ...node.attrs,
                  [attributeName]: generateID({ node, pos })
                });
              }
            });
          });
          if (!tr.steps.length) {
            return;
          }
          tr.setStoredMarks(newState.tr.storedMarks);
          tr.setMeta("__uniqueIDTransaction", true);
          return tr;
        },
        // we register a global drag handler to track the current drag source element
        view(view) {
          const handleDragstart = (event) => {
            var _a;
            dragSourceElement = ((_a = view.dom.parentElement) == null ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
          };
          window.addEventListener("dragstart", handleDragstart);
          return {
            destroy() {
              window.removeEventListener("dragstart", handleDragstart);
            }
          };
        },
        props: {
          // `handleDOMEvents` is called before `transformPasted`
          // so we can do some checks before
          handleDOMEvents: {
            // only create new ids for dropped content
            // or dropped content while holding `alt`
            // or content is dragged from another editor
            drop: (view, event) => {
              var _a, _b;
              if (dragSourceElement !== view.dom.parentElement || ((_a = event.dataTransfer) == null ? void 0 : _a.effectAllowed) === "copyMove" || ((_b = event.dataTransfer) == null ? void 0 : _b.effectAllowed) === "copy") {
                dragSourceElement = null;
                transformPasted = true;
              }
              return false;
            },
            // always create new ids on pasted content
            paste: () => {
              transformPasted = true;
              return false;
            }
          },
          // we’ll remove ids for every pasted node
          // so we can create a new one within `appendTransaction`
          transformPasted: (slice) => {
            if (!transformPasted) {
              return slice;
            }
            const { types, attributeName } = this.options;
            const removeId = (fragment) => {
              const list = [];
              fragment.forEach((node) => {
                if (node.isText) {
                  list.push(node);
                  return;
                }
                if (!types.includes(node.type.name)) {
                  list.push(node.copy(removeId(node.content)));
                  return;
                }
                const nodeWithoutId = node.type.create(
                  {
                    ...node.attrs,
                    [attributeName]: null
                  },
                  removeId(node.content),
                  node.marks
                );
                list.push(nodeWithoutId);
              });
              return import_model.Fragment.from(list);
            };
            transformPasted = false;
            return new import_model.Slice(removeId(slice.content), slice.openStart, slice.openEnd);
          }
        }
      })
    ];
  }
});

// src/generate-unique-ids.ts
var import_core2 = require("@tiptap/core");
var import_model2 = require("@tiptap/pm/model");
var import_state2 = require("@tiptap/pm/state");
function generateUniqueIds(doc, extensions) {
  const uniqueIDExtension = extensions.find((ext) => ext.name === "uniqueID");
  if (!uniqueIDExtension) {
    throw new Error("UniqueID extension not found in the extensions array");
  }
  const { types, attributeName, generateID } = uniqueIDExtension.options;
  const schema = (0, import_core2.getSchema)([...extensions.filter((ext) => ext.name !== "uniqueID"), uniqueIDExtension]);
  const contentNode = import_model2.Node.fromJSON(schema, doc);
  const nodesWithoutId = (0, import_core2.findChildren)(contentNode, (node) => {
    return !node.attrs[attributeName] && types.includes(node.type.name);
  });
  let tr = import_state2.EditorState.create({
    doc: contentNode
  }).tr;
  for (const { node, pos } of nodesWithoutId) {
    tr = tr.setNodeAttribute(pos, attributeName, generateID({ node, pos }));
  }
  return tr.doc.toJSON();
}

// src/index.ts
var index_default = UniqueID;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  UniqueID,
  generateUniqueIds
});
//# sourceMappingURL=index.cjs.map