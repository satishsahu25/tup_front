{"version":3,"sources":["../src/unique-id.ts","../src/helpers/removeDuplicates.ts","../src/helpers/findDuplicates.ts","../src/generate-unique-ids.ts","../src/index.ts"],"sourcesContent":["import { combineTransactionSteps, Extension, findChildren, findChildrenInRange, getChangedRanges } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Fragment, Slice } from '@tiptap/pm/model'\nimport type { Transaction } from '@tiptap/pm/state'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport { findDuplicates } from './helpers/findDuplicates.js'\n\nexport type UniqueIDGenerationContext = {\n  node: ProseMirrorNode\n  pos: number\n}\n\nexport interface UniqueIDOptions {\n  /**\n   * The name of the attribute to add the unique ID to.\n   * @default \"id\"\n   */\n  attributeName: string\n  /**\n   * The types of nodes to add unique IDs to.\n   * @default []\n   */\n  types: string[]\n  /**\n   * The function that generates the unique ID. By default, a UUID v4 is\n   * generated. However, you can provide your own function to generate the\n   * unique ID based on the node type and the position.\n   */\n  generateID: (ctx: UniqueIDGenerationContext) => any\n  /**\n   * Ignore some mutations, for example applied from other users through the collaboration plugin.\n   *\n   * @default null\n   */\n  filterTransaction: ((transaction: Transaction) => boolean) | null\n  /**\n   * Whether to update the document by adding unique IDs to the nodes. Set this\n   * property to `false` if the document is in `readonly` mode, is immutable, or\n   * you don't want it to be modified.\n   *\n   * @default true\n   */\n  updateDocument: boolean\n}\n\nexport const UniqueID = Extension.create<UniqueIDOptions>({\n  name: 'uniqueID',\n\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 10000,\n\n  addOptions() {\n    return {\n      attributeName: 'id',\n      types: [],\n      generateID: () => uuidv4(),\n      filterTransaction: null,\n      updateDocument: true,\n    }\n  },\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: element => element.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: attributes => {\n              if (!attributes[this.options.attributeName]) {\n                return {}\n              }\n\n              return {\n                [`data-${this.options.attributeName}`]: attributes[this.options.attributeName],\n              }\n            },\n          },\n        },\n      },\n    ]\n  },\n\n  // check initial content for missing ids\n  onCreate() {\n    if (!this.options.updateDocument) {\n      return\n    }\n\n    const collaboration = this.editor.extensionManager.extensions.find(ext => ext.name === 'collaboration')\n    const collaborationCaret = this.editor.extensionManager.extensions.find(ext => ext.name === 'collaborationCaret')\n\n    const collabExtensions = [collaboration, collaborationCaret].filter(Boolean)\n    const collab = collabExtensions.find(ext => ext?.options?.provider)\n    const provider = collab?.options?.provider\n\n    const createIds = () => {\n      const { view, state } = this.editor\n      const { tr, doc } = state\n      const { types, attributeName, generateID } = this.options\n      const nodesWithoutId = findChildren(doc, node => {\n        return types.includes(node.type.name) && node.attrs[attributeName] === null\n      })\n\n      nodesWithoutId.forEach(({ node, pos }) => {\n        tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          [attributeName]: generateID({ node, pos }),\n        })\n      })\n\n      tr.setMeta('addToHistory', false)\n\n      view.dispatch(tr)\n\n      if (provider) {\n        provider.off('synced', createIds)\n      }\n    }\n\n    /**\n     * We need to handle collaboration a bit different here\n     * because we can't automatically add IDs when the provider is not yet synced\n     * otherwise we end up with empty paragraphs\n     */\n    if (collab) {\n      if (!provider) {\n        return createIds()\n      }\n\n      provider.on('synced', createIds)\n    } else {\n      return createIds()\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.updateDocument) {\n      return []\n    }\n\n    let dragSourceElement: Element | null = null\n    let transformPasted = false\n\n    return [\n      new Plugin({\n        key: new PluginKey('uniqueID'),\n\n        appendTransaction: (transactions, oldState, newState) => {\n          const hasDocChanges =\n            transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n          const filterTransactions =\n            this.options.filterTransaction && transactions.some(tr => !this.options.filterTransaction?.(tr))\n\n          const isCollabTransaction = transactions.find(tr => tr.getMeta('y-sync$'))\n\n          if (isCollabTransaction) {\n            return\n          }\n\n          if (!hasDocChanges || filterTransactions) {\n            return\n          }\n\n          const { tr } = newState\n\n          const { types, attributeName, generateID } = this.options\n          const transform = combineTransactionSteps(oldState.doc, transactions as Transaction[])\n          const { mapping } = transform\n\n          // get changed ranges based on the old state\n          const changes = getChangedRanges(transform)\n\n          changes.forEach(({ newRange }) => {\n            const newNodes = findChildrenInRange(newState.doc, newRange, node => {\n              return types.includes(node.type.name)\n            })\n\n            const newIds = newNodes.map(({ node }) => node.attrs[attributeName]).filter(id => id !== null)\n\n            newNodes.forEach(({ node, pos }, i) => {\n              // instead of checking `node.attrs[attributeName]` directly\n              // we look at the current state of the node within `tr.doc`.\n              // this helps to prevent adding new ids to the same node\n              // if the node changed multiple times within one transaction\n              const id = tr.doc.nodeAt(pos)?.attrs[attributeName]\n\n              if (id === null) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID({ node, pos }),\n                })\n\n                return\n              }\n\n              const nextNode = newNodes[i + 1]\n\n              if (nextNode && node.content.size === 0) {\n                tr.setNodeMarkup(nextNode.pos, undefined, {\n                  ...nextNode.node.attrs,\n                  [attributeName]: id,\n                })\n                newIds[i + 1] = id\n\n                if (nextNode.node.attrs[attributeName]) {\n                  return\n                }\n\n                const generatedId = generateID({ node, pos })\n\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generatedId,\n                })\n                newIds[i] = generatedId\n\n                return tr\n              }\n\n              const duplicatedNewIds = findDuplicates(newIds)\n\n              // check if the node doesn’t exist in the old state\n              const { deleted } = mapping.invert().mapResult(pos)\n\n              const newNode = deleted && duplicatedNewIds.includes(id)\n\n              if (newNode) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID({ node, pos }),\n                })\n              }\n            })\n          })\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          // `tr.setNodeMarkup` resets the stored marks\n          // so we'll restore them if they exist\n          tr.setStoredMarks(newState.tr.storedMarks)\n\n          // Mark this transaction as coming from UniqueID\n          // to prevent infinite loops with other extensions (e.g., TrailingNode)\n          tr.setMeta('__uniqueIDTransaction', true)\n\n          return tr\n        },\n\n        // we register a global drag handler to track the current drag source element\n        view(view) {\n          const handleDragstart = (event: DragEvent) => {\n            dragSourceElement = view.dom.parentElement?.contains(event.target as Element)\n              ? view.dom.parentElement\n              : null\n          }\n\n          window.addEventListener('dragstart', handleDragstart)\n\n          return {\n            destroy() {\n              window.removeEventListener('dragstart', handleDragstart)\n            },\n          }\n        },\n\n        props: {\n          // `handleDOMEvents` is called before `transformPasted`\n          // so we can do some checks before\n          handleDOMEvents: {\n            // only create new ids for dropped content\n            // or dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (view, event) => {\n              if (\n                dragSourceElement !== view.dom.parentElement ||\n                event.dataTransfer?.effectAllowed === 'copyMove' ||\n                event.dataTransfer?.effectAllowed === 'copy'\n              ) {\n                dragSourceElement = null\n                transformPasted = true\n              }\n\n              return false\n            },\n            // always create new ids on pasted content\n            paste: () => {\n              transformPasted = true\n\n              return false\n            },\n          },\n\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: slice => {\n            if (!transformPasted) {\n              return slice\n            }\n\n            const { types, attributeName } = this.options\n            const removeId = (fragment: Fragment): Fragment => {\n              const list: ProseMirrorNode[] = []\n\n              fragment.forEach(node => {\n                // don’t touch text nodes\n                if (node.isText) {\n                  list.push(node)\n\n                  return\n                }\n\n                // check for any other child nodes\n                if (!types.includes(node.type.name)) {\n                  list.push(node.copy(removeId(node.content)))\n\n                  return\n                }\n\n                // remove id\n                const nodeWithoutId = node.type.create(\n                  {\n                    ...node.attrs,\n                    [attributeName]: null,\n                  },\n                  removeId(node.content),\n                  node.marks,\n                )\n\n                list.push(nodeWithoutId)\n              })\n\n              return Fragment.from(list)\n            }\n\n            // reset check\n            transformPasted = false\n\n            return new Slice(removeId(slice.content), slice.openStart, slice.openEnd)\n          },\n        },\n      }),\n    ]\n  },\n})\n","/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : (seen[key] = true)\n  })\n}\n","import { removeDuplicates } from './removeDuplicates.js'\n\n/**\n * Returns a list of duplicated items within an array.\n */\nexport function findDuplicates(items: any[]): any[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n  const duplicates = removeDuplicates(filtered)\n\n  return duplicates\n}\n","import type { Extensions, JSONContent } from '@tiptap/core'\nimport { findChildren, getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport type { UniqueID } from './unique-id.js'\n\n/**\n * Creates a new document with unique IDs added to the nodes. Does the same\n * thing as the UniqueID extension, but without the need to create an `Editor`\n * instance. This lets you add unique IDs to the document in the server.\n *\n * When you call it, include the `UniqueID` extension in the `extensions` array.\n * The configuration from the `UniqueID` extension will be picked up\n * automatically, including its configuration options like `types` and\n * `attributeName`.\n *\n * @see `UniqueID` extension for more information.\n *\n * @throws {Error} If the `UniqueID` extension is not found in the extensions array.\n *\n * @example\n * const doc = {\n *   type: 'doc',\n *   content: [\n *     { type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }\n *   ]\n * }\n * const newDoc = addUniqueIds(doc, [StarterKit, UniqueID.configure({ types: ['paragraph', 'heading'] })])\n * console.log(newDoc)\n * // Result:\n * // {\n * //   type: 'doc',\n * //   content: [\n * //     { type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }], id: '123' }\n * //   ]\n * // }\n *\n * @param doc - A Tiptap JSON document to add unique IDs to.\n * @param extensions - The extensions to use. Must include the `UniqueID` extension.\n * @returns The updated Tiptap JSON document, with the unique IDs added to the nodes.\n */\nexport function generateUniqueIds(doc: JSONContent, extensions: Extensions): JSONContent {\n  // Find the UniqueID extension in the extensions array. If it's not found, throw an error.\n  const uniqueIDExtension = extensions.find(ext => ext.name === 'uniqueID') as typeof UniqueID | undefined\n  if (!uniqueIDExtension) {\n    throw new Error('UniqueID extension not found in the extensions array')\n  }\n  const { types, attributeName, generateID } = uniqueIDExtension.options\n\n  // Convert the JSON content to a ProseMirror node\n  const schema = getSchema([...extensions.filter(ext => ext.name !== 'uniqueID'), uniqueIDExtension])\n  const contentNode = Node.fromJSON(schema, doc)\n\n  // Find nodes that don't have a unique ID\n  const nodesWithoutId = findChildren(contentNode, node => {\n    return !node.attrs[attributeName] && types.includes(node.type.name)\n  })\n\n  // Edit the document to add unique IDs to the nodes that don't have a unique ID\n  let tr = EditorState.create({\n    doc: contentNode,\n  }).tr\n  // eslint-disable-next-line no-restricted-syntax\n  for (const { node, pos } of nodesWithoutId) {\n    tr = tr.setNodeAttribute(pos, attributeName, generateID({ node, pos }))\n  }\n\n  // Return the updated document\n  return tr.doc.toJSON()\n}\n","import { UniqueID } from './unique-id.js'\n\nexport * from './generate-unique-ids.js'\nexport * from './unique-id.js'\n\nexport default UniqueID\n"],"mappings":";AAAA,SAAS,yBAAyB,WAAW,cAAc,qBAAqB,wBAAwB;AAExG,SAAS,UAAU,aAAa;AAEhC,SAAS,QAAQ,iBAAiB;AAClC,SAAS,MAAM,cAAc;;;ACDtB,SAAS,iBAAoB,OAAY,KAAK,KAAK,WAAgB;AACxE,QAAM,OAAyB,CAAC;AAEhC,SAAO,MAAM,OAAO,UAAQ;AAC1B,UAAM,MAAM,GAAG,IAAI;AAEnB,WAAO,OAAO,UAAU,eAAe,KAAK,MAAM,GAAG,IAAI,QAAS,KAAK,GAAG,IAAI;AAAA,EAChF,CAAC;AACH;;;ACPO,SAAS,eAAe,OAAqB;AAClD,QAAM,WAAW,MAAM,OAAO,CAAC,IAAI,UAAU,MAAM,QAAQ,EAAE,MAAM,KAAK;AACxE,QAAM,aAAa,iBAAiB,QAAQ;AAE5C,SAAO;AACT;;;AFqCO,IAAM,WAAW,UAAU,OAAwB;AAAA,EACxD,MAAM;AAAA;AAAA;AAAA,EAIN,UAAU;AAAA,EAEV,aAAa;AACX,WAAO;AAAA,MACL,eAAe;AAAA,MACf,OAAO,CAAC;AAAA,MACR,YAAY,MAAM,OAAO;AAAA,MACzB,mBAAmB;AAAA,MACnB,gBAAgB;AAAA,IAClB;AAAA,EACF;AAAA,EAEA,sBAAsB;AACpB,WAAO;AAAA,MACL;AAAA,QACE,OAAO,KAAK,QAAQ;AAAA,QACpB,YAAY;AAAA,UACV,CAAC,KAAK,QAAQ,aAAa,GAAG;AAAA,YAC5B,SAAS;AAAA,YACT,WAAW,aAAW,QAAQ,aAAa,QAAQ,KAAK,QAAQ,aAAa,EAAE;AAAA,YAC/E,YAAY,gBAAc;AACxB,kBAAI,CAAC,WAAW,KAAK,QAAQ,aAAa,GAAG;AAC3C,uBAAO,CAAC;AAAA,cACV;AAEA,qBAAO;AAAA,gBACL,CAAC,QAAQ,KAAK,QAAQ,aAAa,EAAE,GAAG,WAAW,KAAK,QAAQ,aAAa;AAAA,cAC/E;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,WAAW;AAxFb;AAyFI,QAAI,CAAC,KAAK,QAAQ,gBAAgB;AAChC;AAAA,IACF;AAEA,UAAM,gBAAgB,KAAK,OAAO,iBAAiB,WAAW,KAAK,SAAO,IAAI,SAAS,eAAe;AACtG,UAAM,qBAAqB,KAAK,OAAO,iBAAiB,WAAW,KAAK,SAAO,IAAI,SAAS,oBAAoB;AAEhH,UAAM,mBAAmB,CAAC,eAAe,kBAAkB,EAAE,OAAO,OAAO;AAC3E,UAAM,SAAS,iBAAiB,KAAK,SAAI;AAjG7C,UAAAA;AAiGgD,cAAAA,MAAA,2BAAK,YAAL,gBAAAA,IAAc;AAAA,KAAQ;AAClE,UAAM,YAAW,sCAAQ,YAAR,mBAAiB;AAElC,UAAM,YAAY,MAAM;AACtB,YAAM,EAAE,MAAM,MAAM,IAAI,KAAK;AAC7B,YAAM,EAAE,IAAI,IAAI,IAAI;AACpB,YAAM,EAAE,OAAO,eAAe,WAAW,IAAI,KAAK;AAClD,YAAM,iBAAiB,aAAa,KAAK,UAAQ;AAC/C,eAAO,MAAM,SAAS,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,aAAa,MAAM;AAAA,MACzE,CAAC;AAED,qBAAe,QAAQ,CAAC,EAAE,MAAM,IAAI,MAAM;AACxC,WAAG,cAAc,KAAK,QAAW;AAAA,UAC/B,GAAG,KAAK;AAAA,UACR,CAAC,aAAa,GAAG,WAAW,EAAE,MAAM,IAAI,CAAC;AAAA,QAC3C,CAAC;AAAA,MACH,CAAC;AAED,SAAG,QAAQ,gBAAgB,KAAK;AAEhC,WAAK,SAAS,EAAE;AAEhB,UAAI,UAAU;AACZ,iBAAS,IAAI,UAAU,SAAS;AAAA,MAClC;AAAA,IACF;AAOA,QAAI,QAAQ;AACV,UAAI,CAAC,UAAU;AACb,eAAO,UAAU;AAAA,MACnB;AAEA,eAAS,GAAG,UAAU,SAAS;AAAA,IACjC,OAAO;AACL,aAAO,UAAU;AAAA,IACnB;AAAA,EACF;AAAA,EAEA,wBAAwB;AACtB,QAAI,CAAC,KAAK,QAAQ,gBAAgB;AAChC,aAAO,CAAC;AAAA,IACV;AAEA,QAAI,oBAAoC;AACxC,QAAI,kBAAkB;AAEtB,WAAO;AAAA,MACL,IAAI,OAAO;AAAA,QACT,KAAK,IAAI,UAAU,UAAU;AAAA,QAE7B,mBAAmB,CAAC,cAAc,UAAU,aAAa;AACvD,gBAAM,gBACJ,aAAa,KAAK,iBAAe,YAAY,UAAU,KAAK,CAAC,SAAS,IAAI,GAAG,SAAS,GAAG;AAC3F,gBAAM,qBACJ,KAAK,QAAQ,qBAAqB,aAAa,KAAK,CAAAC,QAAG;AA5JnE;AA4JsE,sBAAC,gBAAK,SAAQ,sBAAb,4BAAiCA;AAAA,WAAG;AAEjG,gBAAM,sBAAsB,aAAa,KAAK,CAAAA,QAAMA,IAAG,QAAQ,SAAS,CAAC;AAEzE,cAAI,qBAAqB;AACvB;AAAA,UACF;AAEA,cAAI,CAAC,iBAAiB,oBAAoB;AACxC;AAAA,UACF;AAEA,gBAAM,EAAE,GAAG,IAAI;AAEf,gBAAM,EAAE,OAAO,eAAe,WAAW,IAAI,KAAK;AAClD,gBAAM,YAAY,wBAAwB,SAAS,KAAK,YAA6B;AACrF,gBAAM,EAAE,QAAQ,IAAI;AAGpB,gBAAM,UAAU,iBAAiB,SAAS;AAE1C,kBAAQ,QAAQ,CAAC,EAAE,SAAS,MAAM;AAChC,kBAAM,WAAW,oBAAoB,SAAS,KAAK,UAAU,UAAQ;AACnE,qBAAO,MAAM,SAAS,KAAK,KAAK,IAAI;AAAA,YACtC,CAAC;AAED,kBAAM,SAAS,SAAS,IAAI,CAAC,EAAE,KAAK,MAAM,KAAK,MAAM,aAAa,CAAC,EAAE,OAAO,QAAM,OAAO,IAAI;AAE7F,qBAAS,QAAQ,CAAC,EAAE,MAAM,IAAI,GAAG,MAAM;AAxLnD;AA6Lc,oBAAM,MAAK,QAAG,IAAI,OAAO,GAAG,MAAjB,mBAAoB,MAAM;AAErC,kBAAI,OAAO,MAAM;AACf,mBAAG,cAAc,KAAK,QAAW;AAAA,kBAC/B,GAAG,KAAK;AAAA,kBACR,CAAC,aAAa,GAAG,WAAW,EAAE,MAAM,IAAI,CAAC;AAAA,gBAC3C,CAAC;AAED;AAAA,cACF;AAEA,oBAAM,WAAW,SAAS,IAAI,CAAC;AAE/B,kBAAI,YAAY,KAAK,QAAQ,SAAS,GAAG;AACvC,mBAAG,cAAc,SAAS,KAAK,QAAW;AAAA,kBACxC,GAAG,SAAS,KAAK;AAAA,kBACjB,CAAC,aAAa,GAAG;AAAA,gBACnB,CAAC;AACD,uBAAO,IAAI,CAAC,IAAI;AAEhB,oBAAI,SAAS,KAAK,MAAM,aAAa,GAAG;AACtC;AAAA,gBACF;AAEA,sBAAM,cAAc,WAAW,EAAE,MAAM,IAAI,CAAC;AAE5C,mBAAG,cAAc,KAAK,QAAW;AAAA,kBAC/B,GAAG,KAAK;AAAA,kBACR,CAAC,aAAa,GAAG;AAAA,gBACnB,CAAC;AACD,uBAAO,CAAC,IAAI;AAEZ,uBAAO;AAAA,cACT;AAEA,oBAAM,mBAAmB,eAAe,MAAM;AAG9C,oBAAM,EAAE,QAAQ,IAAI,QAAQ,OAAO,EAAE,UAAU,GAAG;AAElD,oBAAM,UAAU,WAAW,iBAAiB,SAAS,EAAE;AAEvD,kBAAI,SAAS;AACX,mBAAG,cAAc,KAAK,QAAW;AAAA,kBAC/B,GAAG,KAAK;AAAA,kBACR,CAAC,aAAa,GAAG,WAAW,EAAE,MAAM,IAAI,CAAC;AAAA,gBAC3C,CAAC;AAAA,cACH;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAED,cAAI,CAAC,GAAG,MAAM,QAAQ;AACpB;AAAA,UACF;AAIA,aAAG,eAAe,SAAS,GAAG,WAAW;AAIzC,aAAG,QAAQ,yBAAyB,IAAI;AAExC,iBAAO;AAAA,QACT;AAAA;AAAA,QAGA,KAAK,MAAM;AACT,gBAAM,kBAAkB,CAAC,UAAqB;AAjQxD;AAkQY,kCAAoB,UAAK,IAAI,kBAAT,mBAAwB,SAAS,MAAM,WACvD,KAAK,IAAI,gBACT;AAAA,UACN;AAEA,iBAAO,iBAAiB,aAAa,eAAe;AAEpD,iBAAO;AAAA,YACL,UAAU;AACR,qBAAO,oBAAoB,aAAa,eAAe;AAAA,YACzD;AAAA,UACF;AAAA,QACF;AAAA,QAEA,OAAO;AAAA;AAAA;AAAA,UAGL,iBAAiB;AAAA;AAAA;AAAA;AAAA,YAIf,MAAM,CAAC,MAAM,UAAU;AAvRnC;AAwRc,kBACE,sBAAsB,KAAK,IAAI,mBAC/B,WAAM,iBAAN,mBAAoB,mBAAkB,gBACtC,WAAM,iBAAN,mBAAoB,mBAAkB,QACtC;AACA,oCAAoB;AACpB,kCAAkB;AAAA,cACpB;AAEA,qBAAO;AAAA,YACT;AAAA;AAAA,YAEA,OAAO,MAAM;AACX,gCAAkB;AAElB,qBAAO;AAAA,YACT;AAAA,UACF;AAAA;AAAA;AAAA,UAIA,iBAAiB,WAAS;AACxB,gBAAI,CAAC,iBAAiB;AACpB,qBAAO;AAAA,YACT;AAEA,kBAAM,EAAE,OAAO,cAAc,IAAI,KAAK;AACtC,kBAAM,WAAW,CAAC,aAAiC;AACjD,oBAAM,OAA0B,CAAC;AAEjC,uBAAS,QAAQ,UAAQ;AAEvB,oBAAI,KAAK,QAAQ;AACf,uBAAK,KAAK,IAAI;AAEd;AAAA,gBACF;AAGA,oBAAI,CAAC,MAAM,SAAS,KAAK,KAAK,IAAI,GAAG;AACnC,uBAAK,KAAK,KAAK,KAAK,SAAS,KAAK,OAAO,CAAC,CAAC;AAE3C;AAAA,gBACF;AAGA,sBAAM,gBAAgB,KAAK,KAAK;AAAA,kBAC9B;AAAA,oBACE,GAAG,KAAK;AAAA,oBACR,CAAC,aAAa,GAAG;AAAA,kBACnB;AAAA,kBACA,SAAS,KAAK,OAAO;AAAA,kBACrB,KAAK;AAAA,gBACP;AAEA,qBAAK,KAAK,aAAa;AAAA,cACzB,CAAC;AAED,qBAAO,SAAS,KAAK,IAAI;AAAA,YAC3B;AAGA,8BAAkB;AAElB,mBAAO,IAAI,MAAM,SAAS,MAAM,OAAO,GAAG,MAAM,WAAW,MAAM,OAAO;AAAA,UAC1E;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF,CAAC;;;AG7VD,SAAS,gBAAAC,eAAc,iBAAiB;AACxC,SAAS,YAAY;AACrB,SAAS,mBAAmB;AAuCrB,SAAS,kBAAkB,KAAkB,YAAqC;AAEvF,QAAM,oBAAoB,WAAW,KAAK,SAAO,IAAI,SAAS,UAAU;AACxE,MAAI,CAAC,mBAAmB;AACtB,UAAM,IAAI,MAAM,sDAAsD;AAAA,EACxE;AACA,QAAM,EAAE,OAAO,eAAe,WAAW,IAAI,kBAAkB;AAG/D,QAAM,SAAS,UAAU,CAAC,GAAG,WAAW,OAAO,SAAO,IAAI,SAAS,UAAU,GAAG,iBAAiB,CAAC;AAClG,QAAM,cAAc,KAAK,SAAS,QAAQ,GAAG;AAG7C,QAAM,iBAAiBA,cAAa,aAAa,UAAQ;AACvD,WAAO,CAAC,KAAK,MAAM,aAAa,KAAK,MAAM,SAAS,KAAK,KAAK,IAAI;AAAA,EACpE,CAAC;AAGD,MAAI,KAAK,YAAY,OAAO;AAAA,IAC1B,KAAK;AAAA,EACP,CAAC,EAAE;AAEH,aAAW,EAAE,MAAM,IAAI,KAAK,gBAAgB;AAC1C,SAAK,GAAG,iBAAiB,KAAK,eAAe,WAAW,EAAE,MAAM,IAAI,CAAC,CAAC;AAAA,EACxE;AAGA,SAAO,GAAG,IAAI,OAAO;AACvB;;;ACjEA,IAAO,gBAAQ;","names":["_a","tr","findChildren"]}